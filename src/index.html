<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Route Optimizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Fragment+Mono:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="normalize.css">
  <link rel="stylesheet" href="styles.css">
  <script src="https://unpkg.com/lucide@latest"></script>
</head>

<body>
  <!-- Header Section -->
  <header>
    <i data-lucide="map" class="header-icon" stroke-width="1.5"></i>
    <h1 class="title">Route Optimizer<span class="phase">Phase 2</span></h1>
  </header>

  <!-- Main Content Section -->
  <main class="cards">

    <!-- Canvas -->
    <div class="canvas card">
      <span>Canvas:312x450</span>
    </div>

    <!-- Upload Button -->
    <div class="upload card">
      <input id="upload-btn" type="file" accept=".json" hidden>
      <label for="upload-btn" class="icon-text-upload">
        <i data-lucide="file-json"></i>
        <span id="upload-text">Upload Your Map</span>
      </label>
      <i data-lucide="info" id="info"></i>
      <span class="note">*accept Only file .JSON</span>
    </div>

    <!-- Algorithm Selection -->
    <div class="algorithm-select card">
      <div class="algorithm">
        <i data-lucide="cpu"></i>
        <h2>Algorithm</h2>
      </div>
      <hr>
      <div class="algorithm-btn">
        <button id="run-dijkstra">
          <h3>Dijkstra</h3>
          <i data-lucide="circle-check"></i>
        </button>
        <div class="disabled">
          <button id="run-A*">
            <h3>A* Search</h3>
            <i data-lucide="lock"></i>
          </button>
          <button id="run-bellman">
            <h3>Bellman</h3>
            <i data-lucide="lock"></i>
          </button>
        </div>
      </div>
      <hr>
      <button id="run-btn">
        <i data-lucide="play-circle"></i>
        <h3>Run</h3>
      </button>
    </div>

    <!-- Algorithm Code Display -->
    <div class="code-wrapper">
      <div class="algorithm-code card">
        <span>Code Display</span>
        <div class="circles">
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
        </div>
      </div>

      <div class="code card">
        <pre><code id="code-display">/**
 * Dijkstra Algorithm Class
 * This class handles the logic for finding the shortest path in a weighted graph.
 * It converts raw JSON data into an Adjacency List and executes the algorithm.
 */
class Dijkstra {
  /**
   * Constructor
   * @param {Object} graphData - The JSON object containing nodes, edges, startNode, and endNode.
   */
  constructor(graphData) {
    // Note: We use 'this.' to define class properties. Unlike 'let' variables which are temporary to the function,
    // 'this.' properties persist and can be accessed in other methods like run().

    // We use a Map for the adjacency list for better performance (O(1) access time)
    this.adjacencyList = new Map();

    // Capture Start and End nodes from JSON configuration
    this.defaultStart = graphData.startNode || null;
    this.defaultEnd = graphData.endNode || null;

    // 1. Initialize all nodes in the adjacency list with empty arrays
    if (graphData.nodes) {
      graphData.nodes.forEach((node) => {
        this.adjacencyList.set(node.id, []);
      });
    }

    // 2. Populate the adjacency list with edges (Connections)
    if (graphData.edges) {
      graphData.edges.forEach((edge) => {
        // Check if the 'from' node exists to avoid errors
        if (this.adjacencyList.has(edge.from)) {
          this.adjacencyList.get(edge.from).push({
            to: edge.to,
            weight: edge.weight,
          });
        }
      });
    }
  }

  /**
   * Helper Method: getLowestCostNode
   * Finds the unvisited node with the smallest known distance.
   * This represents the "Greedy" step of the algorithm.
   * * @param {Map} distances - Current known distances.
   * @param {Set} unvisited - Set of nodes that haven't been processed yet.
   * @returns {String|null} - The ID of the node with the lowest cost.
   */
  getLowestCostNode(distances, unvisited) {
    let lowestNode = null;
    let lowestValue = Infinity;

    // Iterate through unvisited nodes to find the minimum distance
    for (let nodeId of unvisited) {
      let dist = distances.get(nodeId);
      if (dist < lowestValue) {
        lowestValue = dist;
        lowestNode = nodeId;
      }
    }
    return lowestNode;
  }

  /**
   * Main Method: run
   * Executes Dijkstra's algorithm from a start node to an end node.
   * Uses defaults from JSON if arguments are not provided.
   * * @param {String} [startNodeId] - Optional override for start node.
   * @param {String} [endNodeId] - Optional override for destination node.
   * @returns {Object} - Contains found status, path array, total cost, and execution logs.
   */
  run(startNodeId = this.defaultStart, endNodeId = this.defaultEnd) {
    let logs = []; // Records steps for visualization/debugging

    // VALIDATION: Ensure start and end nodes are defined
    if (!startNodeId || !endNodeId) {
      logs.push("Error: Start or End node not defined in JSON or arguments.");
      return { found: false, path: [], cost: 0, logs: logs };
    }

    // VALIDATION: Ensure nodes exist in the graph
    if (
      !this.adjacencyList.has(startNodeId) ||
      !this.adjacencyList.has(endNodeId)
    ) {
      logs.push(
        `Error: Nodes ${startNodeId} or ${endNodeId} do not exist in the graph.`
      );
      return { found: false, path: [], cost: 0, logs: logs };
    }

    // --- Data Structures ---
    let distances = new Map(); // Stores the shortest distance from start to each node
    let previous = new Map(); // Stores the path history (breadcrumbs)
    let unvisited = new Set(); // Tracks nodes that need to be processed

    // --- Initialization ---
    // Set all distances to Infinity and add all nodes to the unvisited set
    for (let nodeId of this.adjacencyList.keys()) {
      distances.set(nodeId, Infinity);
      previous.set(nodeId, null);
      unvisited.add(nodeId);
    }

    // The distance to the start node is always 0
    distances.set(startNodeId, 0);
    logs.push(`Initial state: Start at [${startNodeId}] with distance 0`);

    // --- Main Algorithm Loop ---
    while (unvisited.size > 0) {
      // Step 1: Select the unvisited node with the lowest distance
      let currentNode = this.getLowestCostNode(distances, unvisited);

      // STOP CONDITION 1: No reachable nodes left (or graph is disconnected)
      if (currentNode === null || distances.get(currentNode) === Infinity) {
        break;
      }

      // STOP CONDITION 2: Target reached
      if (currentNode === endNodeId) {
        logs.push(`Target [${endNodeId}] reached!`);
        break;
      }

      // Step 2: Mark the current node as visited
      logs.push(
        `Visiting node [${currentNode}] with current cost ${distances.get(
          currentNode
        )}`
      );
      unvisited.delete(currentNode);

      // Step 3: Explore Neighbors (Relaxation Step)
      let neighbors = this.adjacencyList.get(currentNode) || [];

      for (let neighbor of neighbors) {
        // Skip nodes that have already been fully processed
        if (!unvisited.has(neighbor.to)) continue;

        // Calculate potential new distance
        let newDist = distances.get(currentNode) + neighbor.weight;
        let currentNeighborDist = distances.get(neighbor.to);

        // If we found a shorter path, update the records
        if (newDist < currentNeighborDist) {
          distances.set(neighbor.to, newDist);
          previous.set(neighbor.to, currentNode); // Point back to where we came from

          logs.push(
            `Updated [${neighbor.to}]: old cost ${currentNeighborDist} -> new cost ${newDist} (via ${currentNode})`
          );
        }
      }
    }

    // --- Path Reconstruction (Backtracking) ---
    let path = [];
    let current = endNodeId;

    // Check if the destination is still unreachable (Infinity)
    if (distances.get(endNodeId) === Infinity) {
      return { found: false, path: [], cost: 0, logs: logs };
    }

    // Backtrack from End to Start using the 'previous' map
    while (current !== null) {
      path.unshift(current); // Add to the beginning of the array
      current = previous.get(current);
    }

    return {
      found: true,
      path: path,
      cost: distances.get(endNodeId),
      logs: logs,
    };
  }
}
</code></pre>
      </div>
    </div>

    <!-- Execution Log Display -->
    <div class="code-wrapper">
      <div class="execution-log algorithm-code  card">
        <span>Execution Log</span>
      </div>
      <div class="log code card">
        <pre><code id="log-display">&gt; System initialized.<br>&gt; Waiting for map data...<br>&gt; Ready.</code></pre>
      </div>
    </div>
  </main>

  <!-- Footer Section -->
  <footer>
    <div class="links">
      <a href="#">About</a>
      <a href="#">Our Team</a>
      <a href="#">Help</a>
    </div>
    <span>Â© 2025 Route Optimizer. All rights reserved.</span>
  </footer>

  <script>
    lucide.createIcons();
  </script>
  <script src="script.js"></script>
  <script src="Dijkstra.js"></script>
</body>

</html>